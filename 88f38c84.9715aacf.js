(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return l}));var a=n(3),r=(n(0),n(88));const i={id:"first-service",title:"Creating an ECS Service",sidebar_label:"Creating an ECS Service",slug:"/adding-a-service"},s={unversionedId:"first-service",id:"first-service",isDocsHomePage:!1,title:"Creating an ECS Service",description:"Our translation application is made up of two services. One service is the frontend service, which renders the UI to the user and handles the submission of their request to translate text.",source:"@site/docs/first-service.md",slug:"/adding-a-service",permalink:"/ecs-microservices-workshop/adding-a-service",editUrl:"https://github.com/samdjstevens/ecs-microservices-workshop/edit/master/docs/first-service.md",version:"current",sidebar_label:"Creating an ECS Service",sidebar:"someSidebar",previous:{title:"Creating the ECS cluster",permalink:"/ecs-microservices-workshop/creating-the-ecs-cluster"},next:{title:"Discovering services",permalink:"/ecs-microservices-workshop/discovering-services"}},o=[{value:"How it works",id:"how-it-works",children:[]},{value:"Source Code",id:"source-code",children:[]},{value:"Pulling the application image from ECR",id:"pulling-the-application-image-from-ecr",children:[]},{value:"Creating the Task Definition",id:"creating-the-task-definition",children:[]},{value:"Creating the service",id:"creating-the-service",children:[]},{value:"Making a request to the service",id:"making-a-request-to-the-service",children:[]}],c={toc:o};function l({components:e,...t}){return Object(r.b)("wrapper",Object(a.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Our translation application is made up of two services. One service is the ",Object(r.b)("strong",{parentName:"p"},"frontend service"),", which renders the UI to the user and handles the submission of their request to translate text."),Object(r.b)("p",null,"The second service is the ",Object(r.b)("strong",{parentName:"p"},"backend translate-api service")," - a JSON API service which accepts translation requests and returns responses containing the translated text."),Object(r.b)("p",null,"We will start by deploying the ",Object(r.b)("strong",{parentName:"p"},"translate-api")," service to the cluster first."),Object(r.b)("h3",{id:"how-it-works"},"How it works"),Object(r.b)("p",null,"The translate-api service is a simple ",Object(r.b)("a",{parentName:"p",href:"https://spring.io/projects/spring-boot"},"Spring Boot")," based application written in Java, that uses the AWS SDK to talk to the ",Object(r.b)("a",{parentName:"p",href:"https://aws.amazon.com/translate/"},"Amazon Translate")," service. "),Object(r.b)("p",null,"It has a single endpoint, ",Object(r.b)("inlineCode",{parentName:"p"},"/translate"),", which accepts a JSON body detailing the source language, target language, and the text to translate."),Object(r.b)("p",null,"Example request:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n    "sourceLangCode": "en",\n    "targetLangCode": "fr",\n    "text": "Hello World!"\n}\n')),Object(r.b)("p",null,"Example response:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n    "sourceLangCode": "en",\n    "targetLangCode": "fr",\n    "translatedText": "Bonjour le monde!"\n}\n')),Object(r.b)("h3",{id:"source-code"},"Source Code"),Object(r.b)("p",null,Object(r.b)("a",{parentName:"p",href:"https://github.com/samdjstevens/ecs-microservices-translate-api"},"Click here")," to view the source code of the service on GitHub."),Object(r.b)("h3",{id:"pulling-the-application-image-from-ecr"},"Pulling the application image from ECR"),Object(r.b)("p",null,"I have pushed the docker image for the service up to a ",Object(r.b)("a",{parentName:"p",href:"https://gallery.ecr.aws/f0u6x9s9/ecs-microservices-translate-api"},"public ECR repository"),", so that it can be pulled down by the ECS when deploying the task."),Object(r.b)("h3",{id:"creating-the-task-definition"},"Creating the Task Definition"),Object(r.b)("p",null,"To start creating the service which will run the docker containers of the application, we must first create a ",Object(r.b)("strong",{parentName:"p"},"task definition")," describing how to run the container."),Object(r.b)("p",null,"Add/change the highlighted lines below to the stack:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript",metastring:'title="lib/translatr-cdk-stack.ts" {3,21-42}',title:'"lib/translatr-cdk-stack.ts"',"{3,21-42}":!0},"import { Stack, StackProps } from 'aws-cdk-lib';\nimport { Construct } from 'constructs';\nimport { aws_ec2 as ec2, aws_ecs as ecs, aws_iam as iam, aws_ecr as ecr } from 'aws-cdk-lib';\n\nexport class TranslatrCdkStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'ClusterVpc', {\n        cidr: '10.0.0.0/16',\n        maxAzs: 2\n    })\n\n    new ec2.BastionHostLinux(this, 'Bastion', { vpc })\n\n    const cluster = new ecs.Cluster(this, 'EcsCluster', {\n        vpc,\n        clusterName: 'translatr',\n    })\n\n    // Create the task definition\n    const translateApiTaskDefinition = new ecs.FargateTaskDefinition(\n        this, \n        'TranslateApiTaskDef'\n    );\n\n    // Give the container in the task definition access to Amazon Translate\n    translateApiTaskDefinition.taskRole.addManagedPolicy(\n        iam.ManagedPolicy.fromAwsManagedPolicyName('TranslateFullAccess')\n    );\n\n    const container = translateApiTaskDefinition.addContainer('app', {\n        image: ecs.ContainerImage.fromRegistry('public.ecr.aws/f0u6x9s9/ecs-microservices-translate-api'),\n        // Send logs from the container to Cloudwatch\n        logging: new ecs.AwsLogDriver({ streamPrefix: 'translate-api' })\n    })\n\n    // Expose port 80 on the container\n    container.addPortMappings({\n        containerPort: 80,\n        hostPort: 80\n    })\n\n  }\n}\n")),Object(r.b)("p",null,"In this addition, we create a new Task Definition that will run on ",Object(r.b)("strong",{parentName:"p"},"Fargate"),", and assign the AWS managed ",Object(r.b)("a",{parentName:"p",href:"https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/TranslateFullAccess$jsonEditor"},'"TranslateFullAccess" IAM policy')," to it. By doing this, we give the app that will be running in the container inside this task the permissions to make the API calls to AWS Translate service."),Object(r.b)("p",null,"Next, we add a single container to the task definition, specifying the ",Object(r.b)("strong",{parentName:"p"},"Elastic Container Registry")," where the app image lives, and that we want to use the AWS log driver for the container logs. When using this driver, AWS will automatically create a log group in Cloudwatch Logs and ship the container logs to it."),Object(r.b)("p",null,"To finish the Task Definition, we add the port mappings on the container, exposing the application which is listening on port 80."),Object(r.b)("h3",{id:"creating-the-service"},"Creating the service"),Object(r.b)("p",null,"We have defined/created the task definition, and are now ready to create the service which will take care of running the instances of those tasks."),Object(r.b)("p",null,"Add the highlighted lines below to the stack:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript",metastring:'title="lib/translatr-cdk-stack.ts" {17-30}',title:'"lib/translatr-cdk-stack.ts"',"{17-30}":!0},"import { Stack, StackProps } from 'aws-cdk-lib';\nimport { Construct } from 'constructs';\nimport { aws_ec2 as ec2, aws_ecs as ecs, aws_iam as iam } from 'aws-cdk-lib';\n\nexport class TranslatrCdkStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    ...\n\n    // Expose port 80 on the container\n    container.addPortMappings({\n        containerPort: 80,\n        hostPort: 80\n    })\n\n    // Allow inbound traffic from within the VPC on port 80\n    const appTaskDefinitionSecurityGroup = new ec2.SecurityGroup(this, 'TranslateApiServiceSecurityGroup', {\n        vpc,\n        securityGroupName: 'translate-api-sg'\n    })\n    appTaskDefinitionSecurityGroup.addIngressRule(ec2.Peer.ipv4(vpc.vpcCidrBlock), ec2.Port.tcp(80));\n\n    const service = new ecs.FargateService(this, 'TransateApiService', {\n        cluster,\n        serviceName: 'translate-api',\n        taskDefinition: translateApiTaskDefinition,\n        desiredCount: 3,\n        securityGroups: [appTaskDefinitionSecurityGroup]\n    })\n\n  }\n}\n")),Object(r.b)("p",null,"We start by creating a ",Object(r.b)("strong",{parentName:"p"},"Security Group")," which is like a firewall that controls what connections will be accepted and rejected. By default, the services on a cluster will have no security groups, which means all connections will be rejected. Security Groups are ",Object(r.b)("em",{parentName:"p"},"stateful"),", which basically means we don't need to explicitly state that the connection back to the originator is allowed."),Object(r.b)("p",null,"In the security group, we allow all incoming connections from ",Object(r.b)("strong",{parentName:"p"},"within the VPC")," to port 80 on our service. This means that requests to the service from within the VPC will be allowed, whilst requetss from outside of it (if the service was publically available) would be rejected."),Object(r.b)("p",null,"We then create a new ",Object(r.b)("inlineCode",{parentName:"p"},"FargateService"),", specifying the cluster it should go in, the name, which task definition to use, how many instances of the task definition to run, and finally to use the security group we created."),Object(r.b)("p",null,"Run ",Object(r.b)("inlineCode",{parentName:"p"},"cdk deploy")," to deploy the changes to the stack and create the service."),Object(r.b)("h2",{id:"making-a-request-to-the-service"},"Making a request to the service"),Object(r.b)("p",null,"Our service should now be up and running, ready to handle translation requests - but how can we do a simple check to verify this?"),Object(r.b)("p",null,"Open up the AWS console and head to the ",Object(r.b)("a",{parentName:"p",href:"https://eu-west-1.console.aws.amazon.com/ecs/home?region=eu-west-1#/clusters"},"ECS cluster dashboard")," where you should see the cluster that you previously created. Click on the cluster and open the ",Object(r.b)("strong",{parentName:"p"},"Services")," tab, find the ",Object(r.b)("strong",{parentName:"p"},"translate-api")," service, and click on the link. "),Object(r.b)("p",null,"Open the ",Object(r.b)("strong",{parentName:"p"},"Tasks")," tab to view the three running tasks. Click the Task UUID link on any of the tasks to view the details of the running task."),Object(r.b)("p",null,"Look on this page for the ",Object(r.b)("strong",{parentName:"p"},"Private I.P.")," address (note that the task does ",Object(r.b)("em",{parentName:"p"},"not")," have a public I.P. address, as we have not publically exposed the tasks). The container running inside of this task will be reachable at port 80 on the private I.P. address listed. In my case, it's ",Object(r.b)("inlineCode",{parentName:"p"},"10.0.154.29"),"."),Object(r.b)("p",null,"To connect to this private IP, we need to connect from a machine from within the VPC. Head to the ",Object(r.b)("a",{parentName:"p",href:"https://eu-west-1.console.aws.amazon.com/ec2/v2/home?region=eu-west-1#Instances"},"EC2 instances listing page"),", where you should see the ",Object(r.b)("a",{parentName:"p",href:"/ecs-microservices-workshop/creating-the-vpc#creating-a-bastion-host"},"bastion host")," instance up and running. Connect to the EC2 instance by checking the box next to the instance and selecting ",Object(r.b)("em",{parentName:"p"},"Actions > Connect"),"."),Object(r.b)("p",null,"Choose ",Object(r.b)("strong",{parentName:"p"},"Session Manager")," and hit ",Object(r.b)("em",{parentName:"p"},"Connect"),", and a terminal-like window open in the browser. Check the health endpoint of the translate-api service instance with the following command:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"curl http://<Private-IP>/actuator/health\n")),Object(r.b)("p",null,"You should get back the following response:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{ "status": "UP" }\n')),Object(r.b)("p",null,"The instance is healthy! Let's test the actual functionality of the service by issuing it a translation request:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},'curl --location --request POST \'http://<Private-IP>/translate\' \\\n--header \'Content-Type: application/json\' \\\n--data-raw \'{\n    "sourceLangCode": "en",\n    "targetLangCode": "de",\n    "text": "You will face many defeats in life, but never let yourself be defeated."\n}\'\n')),Object(r.b)("p",null,"You should get the following response back:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{\n    "sourceLangCode": "en",\n    "targetLangCode": "de",\n    "translatedText": "Du wirst mit vielen Niederlagen im Leben konfrontiert sein, aber lass dich niemals besiegen."\n}\n')),Object(r.b)("p",null,"So we have a working service deployed onto the cluster, but there are a few problems. "),Object(r.b)("p",null,"To get the I.P addresses of each instance of the service we need to manually locate it in the AWS console. We also have no way of balancing requests between the instances of the services. And to make matters worse, as instances come up and down from scaling, deployment, failure, etc, the I.P addresses of the running instances will change."),Object(r.b)("p",null,"We can fix all these problems by making the instances of the service ",Object(r.b)("em",{parentName:"p"},"discoverable"),". Continue onto the next step to see how we can do this within AWS."))}l.isMDXComponent=!0},88:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,b=h["".concat(s,".").concat(d)]||h[d]||u[d]||i;return n?r.a.createElement(b,o(o({ref:t},l),{},{components:n})):r.a.createElement(b,o({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);