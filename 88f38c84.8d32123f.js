(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return l}));var a=n(3),r=(n(0),n(88));const i={id:"first-service",title:"Adding a Service",sidebar_label:"Adding a Service",slug:"/adding-a-service"},s={unversionedId:"first-service",id:"first-service",isDocsHomePage:!1,title:"Adding a Service",description:"[TODO]",source:"@site/docs/first-service.md",slug:"/adding-a-service",permalink:"/ecs-microservices-workshop/adding-a-service",editUrl:"https://github.com/samdjstevens/ecs-microservices-workshop/edit/master/docs/first-service.md",version:"current",sidebar_label:"Adding a Service",sidebar:"someSidebar",previous:{title:"Creating the ECS cluster",permalink:"/ecs-microservices-workshop/creating-the-ecs-cluster"},next:{title:"Discovering services",permalink:"/ecs-microservices-workshop/discovering-services"}},o=[{value:"Source Code",id:"source-code",children:[]},{value:"Pushing the images to ECR",id:"pushing-the-images-to-ecr",children:[]},{value:"Creating the Task Definition",id:"creating-the-task-definition",children:[]},{value:"Creating the service",id:"creating-the-service",children:[]},{value:"Making a request to the service",id:"making-a-request-to-the-service",children:[]}],c={toc:o};function l({components:e,...t}){return Object(r.b)("wrapper",Object(a.a)({},c,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("p",null,"[TODO]"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"What the service is"),Object(r.b)("li",{parentName:"ul"},"What were going to do")),Object(r.b)("p",null,"Our translation application is made up of two services. One service is the ",Object(r.b)("strong",{parentName:"p"},"frontend service"),", which renders the UI to the user and handles the submission of their request to translate text."),Object(r.b)("p",null,"The second service is the ",Object(r.b)("strong",{parentName:"p"},"backend translate-api service")," - a JSON API service which accepts translation requests and returns responses containing the translated text."),Object(r.b)("p",null,"We will start by deploying the ",Object(r.b)("strong",{parentName:"p"},"translate-api")," service to the cluster first."),Object(r.b)("h3",{id:"source-code"},"Source Code"),Object(r.b)("p",null,"The translate-api service is a simple ",Object(r.b)("a",{parentName:"p",href:"https://spring.io/projects/spring-boot"},"Spring Boot")," based application written in Java, that uses the AWS SDK to talk to the ",Object(r.b)("a",{parentName:"p",href:"https://aws.amazon.com/translate/"},"Amazon Translate")," service. "),Object(r.b)("p",null,Object(r.b)("a",{parentName:"p",href:"https://github.com/samdjstevens/ecs-microservices-translate-api"},"Click here")," to view the source code of the service on GitHub."),Object(r.b)("p",null,"[todo: add more about how it works? listens on port 80 or? notes on building?]"),Object(r.b)("h3",{id:"pushing-the-images-to-ecr"},"Pushing the images to ECR"),Object(r.b)("p",null,"[TODO]"),Object(r.b)("h3",{id:"creating-the-task-definition"},"Creating the Task Definition"),Object(r.b)("p",null,"[TODO]"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"What is a task definition")),Object(r.b)("p",null,"First we need to add the ",Object(r.b)("inlineCode",{parentName:"p"},"@aws-cdk/aws-iam")," and ",Object(r.b)("inlineCode",{parentName:"p"},"@aws-cdk/aws-ecr")," dependencies to our stack. "),Object(r.b)("p",null,"Stop the ",Object(r.b)("inlineCode",{parentName:"p"},"npm run watch")," command and run the following command: "),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"npm install @aws-cdk/aws-iam @aws-cdk/aws-ecr --save && npm run watch\n")),Object(r.b)("p",null,"Then add the highlighted lines below to the stack:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript",metastring:'title="lib/translatr-cdk-stack.ts" {4-5,22-48}',title:'"lib/translatr-cdk-stack.ts"',"{4-5,22-48}":!0},"import * as cdk from '@aws-cdk/core';\nimport * as ec2 from \"@aws-cdk/aws-ec2\";\nimport * as ecs from \"@aws-cdk/aws-ecs\";\nimport * as iam from \"@aws-cdk/aws-iam\";\nimport * as ecr from \"@aws-cdk/aws-ecr\";\n\nexport class TranslatrCdkStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    const vpc = new ec2.Vpc(this, 'ClusterVpc', {\n        cidr: '10.0.0.0/16',\n        maxAzs: 2\n    })\n\n    // Create a new ECS cluster in the VPC\n    const cluster = new ecs.Cluster(this, 'EcsCluster', {\n        vpc,\n        clusterName: 'translattr',\n    })\n\n    // Create the task definition\n    const translateApiTaskDefinition = new ecs.FargateTaskDefinition(\n        this, \n        'TranslateApiTaskDef'\n    );\n\n    // Give the container in the task definition access to Amazon Translate\n    translateApiTaskDefinition.taskRole.addManagedPolicy(\n        iam.ManagedPolicy.fromAwsManagedPolicyName('TranslateFullAccess')\n    );\n\n    const repo = ecr.Repository.fromRepositoryName(\n        this, \n        'Repo', \n        'ecs-microservices-translate-api'\n    );\n\n    const container = translateApiTaskDefinition.addContainer('app', {\n        image: ecs.ContainerImage.fromEcrRepository(repo),\n        logging: new ecs.AwsLogDriver({ streamPrefix: 'translate-api' })\n    })\n\n    // Expose port 80 on the container\n    container.addPortMappings({\n        containerPort: 80,\n        hostPort: 80\n    })\n\n  }\n}\n")),Object(r.b)("p",null,"In this addition, we create a new Task Definition that will run on ",Object(r.b)("strong",{parentName:"p"},"Fargate"),", and assign the AWS managed ",Object(r.b)("a",{parentName:"p",href:"https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/TranslateFullAccess$jsonEditor"},'"TranslateFullAccess" IAM policy')," to it. By doing this, we give the app that will be running in the container inside this task the permissions to make the API calls to AWS Translate service."),Object(r.b)("p",null,"Next, we add a single container to the task definition, specifying the ",Object(r.b)("strong",{parentName:"p"},"Elastic Container Registry")," where the app image lives, and that we want to use the AWS log driver for the container logs. When using this driver, AWS will automatically create a log group in Cloudwatch Logs and ship the container logs to it."),Object(r.b)("p",null,"To finish the Task Definition, we add the port mappings on the container, exposing the application which is listening on port 80."),Object(r.b)("h3",{id:"creating-the-service"},"Creating the service"),Object(r.b)("p",null,"We have the task definition, but need something to actually specify how we want to run it. TODO add more."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript",metastring:'title="lib/translatr-cdk-stack.ts" {19-32}',title:'"lib/translatr-cdk-stack.ts"',"{19-32}":!0},"import * as cdk from '@aws-cdk/core';\nimport * as ec2 from \"@aws-cdk/aws-ec2\";\nimport * as ecs from \"@aws-cdk/aws-ecs\";\nimport * as iam from \"@aws-cdk/aws-iam\";\nimport * as ecr from \"@aws-cdk/aws-ecr\";\n\nexport class TranslatrCdkStack extends cdk.Stack {\n  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    ...\n\n    // Expose port 80 on the container\n    container.addPortMappings({\n        containerPort: 80,\n        hostPort: 80\n    })\n\n    // Allow inbound traffic from within the VPC on port 80\n    const appTaskDefinitionSecurityGroup = new ec2.SecurityGroup(this, 'MySecGroup', {\n        vpc,\n        securityGroupName: 'translate-api-sg'\n    })\n    sg.addIngressRule(ec2.Peer.ipv4(vpc.vpcCidrBlock), ec2.Port.tcp(port));\n\n    const service = new ecs.FargateService(this, 'TransateApiService', {\n        cluster,\n        serviceName: 'translate-api',\n        taskDefinition: taskDefinition,\n        desiredCount: 3,\n        securityGroups: [appTaskDefinitionSecurityGroup]\n    })\n\n  }\n}\n")),Object(r.b)("p",null,"We start by creating a ",Object(r.b)("strong",{parentName:"p"},"Security Group")," which is like a firewall that controls what connections will be accepted and rejected. By default, the services on a cluster will have no security groups, which means all connections will be rejected. Security Groups are *",Object(r.b)("em",{parentName:"p"},"statefull"),", which basically means we don't need to explicitly state that the connection back to the originator is allowed."),Object(r.b)("p",null,"In the security group, we allow all incoming connections from ",Object(r.b)("strong",{parentName:"p"},"within the VPC")," to port 80 on our service. This means that requests to the service from within the VPC will be allowed, whilst requetss from outside of it (if the service was publically available) would be rejected."),Object(r.b)("p",null,"We then create a new ",Object(r.b)("inlineCode",{parentName:"p"},"FargateService"),", specifying the cluster it should go in, the name, which task definition to use, how many instances of the task definition to run, and finally to use the security group we created."),Object(r.b)("p",null,"Run ",Object(r.b)("inlineCode",{parentName:"p"},"cdk deploy")," to deploy the changes to the stack and create the service."),Object(r.b)("h2",{id:"making-a-request-to-the-service"},"Making a request to the service"),Object(r.b)("p",null,"Our service should now be up and running, ready to handle translation requests - but how can we do a simple check to verify this?"),Object(r.b)("p",null,"Open up the AWS console and head to the ",Object(r.b)("a",{parentName:"p",href:"https://eu-west-1.console.aws.amazon.com/ecs/home?region=eu-west-1#/clusters"},"ECS cluster dashboard")," where you should see the cluster that you previously created. Click on the cluster and open the ",Object(r.b)("strong",{parentName:"p"},"Services")," tab, find the ",Object(r.b)("strong",{parentName:"p"},"translate-api")," service, and click on the link. "),Object(r.b)("p",null,"Open the ",Object(r.b)("strong",{parentName:"p"},"Tasks")," tab to view the three running tasks. Click the Task UUID link on any of the tasks to view the details of the running task."),Object(r.b)("p",null,"Look on this page for the ",Object(r.b)("strong",{parentName:"p"},"Private I.P.")," address (note that the task does ",Object(r.b)("em",{parentName:"p"},"not")," have a public I.P address, as we have not publically exposed the tasks). The container running inside of this task will be reachable at port 80 on the private I.P. address listed. In my case, it's ",Object(r.b)("inlineCode",{parentName:"p"},"10.0.154.29"),"."),Object(r.b)("p",null,"To connect to this private IP, we need to connect from a machine from within the VPC. Head to the ",Object(r.b)("a",{parentName:"p",href:"https://eu-west-1.console.aws.amazon.com/ec2/v2/home?region=eu-west-1#Instances"},"EC2 instances listing page"),", where you should see the ",Object(r.b)("a",{parentName:"p",href:"/ecs-microservices-workshop/creating-the-vpc#creating-a-bastion-host"},"bastion host")," instance up and running. Connect to the EC2 instance by checking the box next to the instance and selecting ",Object(r.b)("em",{parentName:"p"},"Actions > Connect"),"."),Object(r.b)("p",null,"Choose ",Object(r.b)("strong",{parentName:"p"},"Session Manager")," and hit ",Object(r.b)("em",{parentName:"p"},"Connect"),", and a terminal-like window open in the browser. Check the health endpoint of the translate-api service instance with the following command:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"curl http://<Private-IP>/actuator/health\n")),Object(r.b)("p",null,"You should get back the following response:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{ "status": "UP" }\n')),Object(r.b)("p",null,"The instance is healthy! Let's test the actual functionality of the service by issuing it a translation request:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},'curl --location --request POST \'http://<Private-IP>/translate\' \\\n--header \'Content-Type: application/json\' \\\n--data-raw \'{\n    "sourceLangCode": "en",\n    "targetLangCode": "de",\n    "text": "You will face many defeats in life, but never let yourself be defeated."\n}\'\n')),Object(r.b)("p",null,"You should get the following response back:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{\n    "sourceLangCode": "en",\n    "targetLangCode": "de",\n    "translatedText": "Du wirst mit vielen Niederlagen im Leben konfrontiert sein, aber lass dich niemals besiegen."\n}\n')),Object(r.b)("p",null,"So we have a working service deployed onto the cluster, but there are a few problems. "),Object(r.b)("p",null,"To get the I.P addresses of each instance of the service we need to manually locate it in the AWS console. We also have no way of balancing requests between the instances of the services. And to make matters worse, as instances come up and down from scaling, deployment, failure, etc, the I.P addresses of the running instances will change."),Object(r.b)("p",null,"We can fix all these problems by making the instances of the service ",Object(r.b)("em",{parentName:"p"},"discoverable"),". Continue onto the next step to see how we can do this within AWS."))}l.isMDXComponent=!0},88:function(e,t,n){"use strict";n.d(t,"a",(function(){return h})),n.d(t,"b",(function(){return b}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),h=p(n),u=a,b=h["".concat(s,".").concat(u)]||h[u]||d[u]||i;return n?r.a.createElement(b,o(o({ref:t},l),{},{components:n})):r.a.createElement(b,o({ref:t},l))}));function b(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);